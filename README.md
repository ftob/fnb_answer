```
ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-linux]
Linux litebackend-apollon 4.10.0-24-generic #28-Ubuntu SMP Wed Jun 14 08:14:34 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
irb 0.9.6(09/06/30)
```

## LEVEL 1

*Q1*
Чем отличается proc от lambda?<br />
*A1*
1. В Ruby есть два способа передачи параметров - strict и loose. Proc так же как Block использует loose режим. Lambda использует strict mode. [https:github.com/ftob/fnb_answer/1/lambda_vs_proc.rb](Example)
2. В Proc return возвращает из родительского метода. В lambda return возвращает в метод. 
<br />
*Q2*
Чем отличается && от and?<br />
*A2*
Приоритетом. У && приоритет выше чем у "and" [https:github.com/ftob/fnb_answer/2/end_example.rb](Example)
<br />

*Q3*
Какие плюсы и минусы Ruby по сравнению с другими современными языками
программирования вы выделяете для себя?<br />
*A3*
Плюсы<br />
1. Многопоточность
2. Большая STL
3. Большое community
4. Утиная типизация
5. Наличие RFC

Минусы<br />
1. Производительность 
2. Отсутствие статических анализаторов кода
3. Обновления, ломающие обратную совместимость

<br />
*Q4*
В каком случае вы бы стали использовать Ruby on Rails для разработки web-
приложения, а в каком — другой фреймворк?<br />

*A4*
1. Монолитные решения с большим кол-вом межсервисного взаимодействия. 
2. Решения с большим кол-вом итераций разработки в сжатые сроки. 
3. Для запуска MVP проекта.
<br />

*Q5*
Вы запустили большой и сложный ruby скрипт на вашем любимом дистрибутиве
Linux, и в процессе работы он намертво «зависает». Как найти причину сбоя?<br />

*A5*
Запускаю скрипт c ключом ```-r debug``` или подключаю pry, ставлю breakpoints и запускаю pry ``script.rb``. Смотрю на чем застряли, правлю код, смотрю дальше<br />

*Q6*
Вы запустили большой и сложный ruby скрипт на вашем любимом дистрибутиве
Linux, и в процессе работы он умирает, исчерпав память, хотя, казалось бы, не
должен. Как найти причину сбоя?<br />

*A6*
Запускаю ruby c ключом ```-r profile``` или подключаю SamSaffron/memory_profiler смотрю на потенциальные места утечки памяти в присвоениях, оборачиваю код профайлером, запускаю через pry, узнаю "что, где, когда", правлю.

*Q7*
Некоторые проекты (Rails и не только) мы запускаем под JRuby. Как вы думаете,
почему?<br />

*A7*

Скорей всего это связано с тем, что в проекте отсутствует concurrency, требуется большая производительность в ущерб скорости на старте приложения, есть legacy code или microservices написанные на Java или Scala - что в свою очередь позволяет переиспользовать код. <br />


*Q8*
Какие плюсы и минусы библиотеки ActiveRecord в Rails вы знаете? Какие
альтернативы существуют? В чем их плюсы и минусы? Какие из них вы
использовали?<br />


*A8*

Я не знаю тонкостей реалиции ActiveRecord в Ruby On Rails и могу рассуждать об ActiveRecord в контексте антипаттернов.  
1. ActiveRecord нарушает принцип единой ответствености. 
2. Полноценное использование DDD подхода возможно только при использовании DCI в проекте, и то на грани фола в связи с использованием First Database подхода
3. Отсутствует (из коробки) возможность работать потоконезависимо с неблокируемыми операциями
4. Отсутствуют mutex's


## LEVEL II

*Q1*
Есть Rails приложение, развернутое на N серверах. В приложение нужно добавить
загрузку и хранение аватаров.
1. Какую библиотеку использовать?
2. Куда складывать аватарки и почему?
3. Как и зачем нужно обрабатывать загружаемые аватарки?
4. Какие проверки загружаемого файла и когда (например, на клиенте, в Nginx
или Rails) лучше всего производить?
5. Как отдавать аватарки пользователю? Какие плюсы и минусы описанного
подхода?
6. Какие еще проблемы и вопросы могут возникнуть при реализации такой
функциональности?<br />

*A1*
1. Есть большое кол-во вариаций библиотек для реализации данной задачи. Лично я бы взял minimagick/minimagick (В отличие от RMagic он еще и на JRuby работает) - для ресайза картинок, (хотя возможно что будет лишним) carrierwave и carrierwave_backgrounder для сохранения картинок асинхронно, fog для хранения в storage openstack, sidekiq для очередей.  
2. В OpenStack file storage. А куда именно - зависит от кол-ва денег в бюджете. Rackspace - сейчас дешевле, потом дороже. AWS - сейчас дороже, потом дешевле. Свой OpenStack сервер - сейчас дороже, потом дороже.
3. Нужно сделать resize, пускать только безопасные форматы (исключать svg и другую ересь), контролировать размер, экранировать небезопасные данные в названии и exif, контролировать размер, производить авторотацию (если конечно это есть в требовании). И все это для того чтобы экономить деньги и не нарушать безопасность.
4. Формат и размер можно проверять на стороне nginx, для того чтобы не загружать tmpfs. Можно еще раз проверить формат на стороне application потому что я не уверен что nginx смотрит в exif. Экранируем название и отправляем очередь, в очереди ауторотейт -> копирование для ресайза + меняем формат на jpg (хорошо жмется) -> ресайз +- меняем на нужное качество (если мне не изменяет память - 75% практически не дает ухудшений) -> получаем exif -> чистим данные -> сохраняем в облако -> записываем в базу данные об оригинале, превью и других копиях.
5. Настраиваем nginx proxy на openstack. Прячем источник от конечного пользователя. <br /> 
Плюсы: Не ломает нам Content-Security-Policy: block or report. Дает нам возможность кешировать аватарки и экономить деньги на траффике. Отказоустойчивость и масштабируемость. Наши линки на аватарки могут умирать по TTL, тем самым мы сохраним privacy для пользователя.<br />
Минусы: Есть overhead равный x * n, где x кол-во активных пользователей, а n - кол-во proxy.
6. Бывает такое, что меняется security key (Не путать с Security Token) для генерации url, главное - вовремя это понять и запросить новый у OpenStack. Прилетают битые картинки как до сериализации, так и после (в связи с чем могут зависнуть очереди). Бинарные данные в exif. Если в проекте уже есть много аватарок, то будет проблема при переносе (тут главное не использовать rsync, так как он на OpenStack API производит запросы на tree store рекурсивно по всем папкам). Есть еще ряд нюансов, можно написать статью на хабре.

*Q2*
Есть большое приложение с десятками тысяч тестов. Как лучше всего
организовать код и тесты, чтобы добиться максимальной скорости прогона
тестов? <br />

*A2*
Метод по Макиавелли. По возможности раскидать код на Gem's и по репозиториям, каждому Gem свои тесты. В TeamCity или Jenkins или другой CI разделить тесты на четные и нечетные и тестировать их параллельно.